# Валидированное и исчерпывающее описание формирования торговых сигналов

Этот документ предоставляет детализированный, многоуровневый разбор логики генерации, подтверждения и исполнения торговых сигналов, а также их оптимизации.

---

### Общая архитектура

Система состоит из нескольких ключевых модулей:
- **`signal_generator.py`**: Отвечает за первичный поиск точек входа ("сигналов-кандидатов") на основе рыночных паттернов.
- **`trading_simulator.py`**: Принимает сигналы-кандидаты, применяет к ним фильтры подтверждения, исполняет сделки и управляет позициями.
- **`strategy_objectives.py`**: Содержит целевые функции для оценки эффективности наборов параметров. Используется оптимизатором.
- **`optuna_optimizer.py`**: Реализует процесс поиска оптимальных параметров стратегии с использованием библиотеки Optuna.
- **`app.py`**: Пользовательский интерфейс на Streamlit, который объединяет все модули, позволяя проводить анализ, симуляции и оптимизацию.

---
### Этап 0: Исходные данные

Ключевым аспектом системы является то, что она **не генерирует, а потребляет** уже обогащенные данные. Процесс сбора и расчета специфических индикаторов (`long_prints`, `short_prints`, `HLdir`) является **внешним** по отношению к данному проекту.

- **Источник:** Данные загружаются из CSV-файлов, расположенных в директории `dataCSV/`.
- **Ожидаемый формат:** Каждый CSV-файл должен содержать как минимум следующие столбцы:
  - `time`: Временная метка (timestamp).
  - `open`, `high`, `low`, `close`: Стандартные цены свечи.
  - `Volume` (переименовывается в `volume`): Объем торгов.
  - `long_prints`: Данные по агрегированным покупкам.
  - `short_prints`: Данные по агрегированным продажам.
  - `HLdir`: Кастомный индикатор направления тренда.

- **Формат и тип данных:**
  - **`long_prints`, `short_prints`**:
    - **Тип:** Числовой (Numeric - integer или float).
    - **Значение:** Неотрицательные числа (`>= 0`).
    - **Предполагаемый смысл:** Агрегированный объем или количество сделок на покупку (`long_prints`) и продажу (`short_prints`) за период свечи.
  - **`HLdir`**:
    - **Тип:** Числовой (Numeric - float).
    - **Диапазон:** Вероятно, от 0 до 1.
    - **Предполагаемый смысл:** Индикатор направления. Значения > 0.5 интерпретируются как восходящий тренд, а <= 0.5 — как нисходящий.
**Вывод:** Качество и логика формирования `long_prints`, `short_prints` и `HLdir` полностью определяются внешним, неизвестным для этого проекта процессом. Данный бэктестер служит для проверки и оптимизации стратегий, построенных на основе этих заранее подготовленных данных.

### Этап 1: Генерация "Сигнала-кандидата" (`signal_generator.py`)

Система ищет специфическое состояние рынка — **консолидацию после роста**. Сигнал-кандидат генерируется на свече `i`, если **одновременно** выполняются четыре условия:

1.  **Условие низкого объема (`low_vol_condition`):**
    *   **Формула:** `volume[i] <= percentile(volume[i-vol_period+1 : i+1], vol_pctl)`
    *   **Смысл:** Текущий объем торгов находится в нижнем `vol_pctl` процентиле по сравнению с объемами за `vol_period` последних свечей. Это указывает на затишье и снижение интереса.

2.  **Условие узкого ценового диапазона (`narrow_rng_condition`):**
    *   **Формула:** `(high[i] - low[i]) <= percentile(range[i-range_period+1 : i+1], rng_pctl)`
    *   **Смысл:** Текущий диапазон свечи находится в нижнем `rng_pctl` процентиле по сравнению с диапазонами за `range_period` последних свечей. Это подтверждает консолидацию цены.

3.  **Условие минимальной волатильности (`high_natr_condition`):**
    *   **Формула:** `NATR(natr_period)[i] > natr_min`
    *   **Смысл:** Нормализованный средний истинный диапазон (NATR) должен быть выше порога `natr_min`. Это критически важный фильтр, который отсеивает периоды полного застоя, требуя наличия минимального "топлива" для будущего движения.
    *   **Вспомогательные формулы:**
        *   `TR = max(high - low, abs(high - prev_close), abs(low - prev_close))` (Истинный диапазон)
        *   `ATR = EMA(TR, period=natr_period)` (Средний истинный диапазон, рассчитывается через экспоненциальное скользящее среднее)
        *   `NATR = (ATR / close) * 100` (Нормализованный ATR в процентах)

4.  **Условие недавнего роста (`growth_condition`):**
    *   **Формула:** `(close[i] - close[i-lookback_period]) / close[i-lookback_period] >= min_growth_pct / 100`
    *   **Смысл:** Цена закрытия текущей свечи `i` выше цены закрытия `lookback_period` свечей назад как минимум на `min_growth_pct` процентов. Это гарантирует, что консолидация происходит на фоне недавнего восходящего тренда.

**Итог Этапа 1:** Если все четыре условия на свече `i` выполнены, эта свеча помечается как имеющая "сигнал-кандидат". Это еще не команда к действию, а лишь триггер для следующего этапа.

---

### Этап 2: Подтверждение направления (`trading_simulator.py`)

Сигнал-кандидат не имеет направления. Направление (лонг или шорт) определяется на той же свече `i` с помощью **альтернативных** методов, выбор которых является параметром стратегии.

1.  **Методы определения направления:**
    *   **Анализ "принтов" (агрегированных покупок/продаж):**
        *   **Формула:** `ratio = sum(long_prints[i-prints_analysis_period+1 : i+1]) / sum(short_prints[i-prints_analysis_period+1 : i+1])`
        *   **Логика:**
            *   `ЛОНГ`, если `ratio > prints_threshold_ratio` (покупатели доминируют).
            *   `ШОРТ`, если `ratio < 1 / prints_threshold_ratio` (продавцы доминируют).
    *   **Анализ индикатора `HLdir`:**
        *   **Формула:** `avg_hldir = SMA(HLdir[i-hldir_window-hldir_offset+1 : i-hldir_offset+1], hldir_window)` (SMA - простое скользящее среднее).
        *   **Параметр `hldir_offset`:** Позволяет сдвигать окно анализа в прошлое. `offset=0` включает текущую свечу, `offset=1` анализирует данные до `i-1`.
        *   **Логика:**
            *   `ЛОНГ`, если `avg_hldir > 0.5` (индикатор показывает восходящий тренд).
            *   `ШОРТ`, если `avg_hldir <= 0.5` (индикатор показывает нисходящий тренд).

2.  **Вариации логики входа (параметр `entry_logic_mode`):**
    *   **`"Принты и HLdir"` (по умолчанию):** Самый строгий режим. Направление сделки определяется, только если **оба** индикатора (принты и HLdir) указывают в одну сторону. Если их мнения расходятся, сигнал-кандидат игнорируется.
    *   **`"Только по принтам"`:** Направление определяется исключительно по анализу принтов.
    *   **`"Только по HLdir"`:** Направление определяется исключительно по индикатору `HLdir`.
    *   **`"Оптимизировать"` (в режиме оптимизации):** Позволяет Optuna самостоятельно выбирать лучший из трех вышеуказанных режимов как один из гиперпараметров.

---

### Этап 3: Вход в позицию и управление рисками

1.  **Вход в сделку:**
    *   Если на свече `i` был получен сигнал-кандидат и было определено четкое направление, то сделка открывается по цене открытия **следующей** свечи (`open[i+1]`).

2.  **Управление рисками (Stop Loss и Take Profit):**
    *   Сразу после входа по цене `entry_price` выставляются статические уровни стопа и профита:
    *   **Для лонга:**
        *   `stop_loss = entry_price * (1 - stop_loss_pct / 100)`
        *   `take_profit = entry_price * (1 + take_profit_pct / 100)`
    *   **Для шорта:**
        *   `stop_loss = entry_price * (1 + stop_loss_pct / 100)`
        *   `take_profit = entry_price * (1 - take_profit_pct / 100)`

3.  **Логика выхода из позиции:**
    *   **Стандартный режим:** Позиция закрывается по первому из наступивших событий:
        1.  Цена достигает уровня `stop_loss`.
        2.  Цена достигает уровня `take_profit`.
        3.  Данные для симуляции заканчиваются (закрытие по последней цене `close`).
    *   **Альтернативный выход (`aggressive_mode=True`):**
        *   В этом режиме система продолжает искать новые сигналы-кандидаты, даже находясь в открытой позиции. Если новый сигнал появляется **до** срабатывания Stop Loss или Take Profit, текущая сделка принудительно закрывается на свече, предшествующей новому сигналу. Это позволяет быстрее переоткрывать позиции.

---

### Этап 4: Мета-логика и оптимизация (`strategy_objectives.py`)

Система не просто следует правилам, но и ищет их наилучшие комбинации.

1.  **Целевая функция (`trading_strategy_objective_high_win_rate`):**
    *   **Цель:** Найти набор параметров, который максимизирует `Win Rate` (процент прибыльных сделок).
    *   **Логика оценки:**
        *   **Штраф за малое число сделок:** Если сделок меньше `min_trades_threshold` (по умолч. 10), результат сильно штрафуется.
        *   **Штраф за убыточность:** Если итоговый PnL <= 0 или Profit Factor < 1, результат также штрафуется.
        *   **Основная метрика:** `score = win_rate * 100`.
        *   **Бонусы:** К основной метрике добавляются небольшие бонусы за общее количество сделок (чтобы различать варианты с одинаковым Win Rate) и за высокий Profit Factor.
    *   **Процесс:** Оптимизатор `Optuna` перебирает тысячи комбинаций параметров (`vol_period`, `natr_min` и т.д.), для каждой запускает симуляцию и получает оценку от целевой функции. В итоге он находит параметры, дающие максимальную оценку.

---

### Служебные и неиспользуемые параметры

- **`enable_additional_filters`**: Этот параметр присутствует в коде интерфейса (`app.py`), но в текущей реализации `signal_generator.py` и `trading_simulator.py` его логика **не используется**. Сигналы генерируются только на основе четырех основных условий.