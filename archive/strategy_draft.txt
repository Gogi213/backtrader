import numpy as np
import pandas as pd
from collections import deque
from pykalman import KalmanFilter
from sklearn.mixture import GaussianMixture
import scipy.stats as stats

class HierarchicalMeanReversionSignalGenerator_10s:
    """
    Адаптированный генератор сигналов для 10-секундных баров.
    ВНИМАНИЕ: Эффективность значительно ниже, чем на тиковых данных.
    """

    def __init__(self, params: dict, hmm_model=None):
        self.params = params
        self.position = 'HOLD'
        self.entry_price = 0
        self.entry_timestamp = 0
        
        # --- Kalman_Estimator ---
        self.kf = KalmanFilter(
            transition_matrices=[1],
            observation_matrices=[1],
            initial_state_mean=params.get('initial_kf_mean', 0),
            initial_state_covariance=params.get('initial_kf_cov', 1),
            observation_covariance=params.get('measurement_noise_r', 0.5), # Увеличим шум для баров
            transition_covariance=params.get('process_noise_q', 0.05)   # Увеличим шум для баров
        )
        self.kf_state_mean = params.get('initial_kf_mean', 0)
        self.kf_state_cov = params.get('initial_kf_cov', 1)
        
        # --- HMM_Detector ---
        self.hmm_model = hmm_model
        self.hmm_observations = deque(maxlen=params['hmm_window_size'])
        self.current_regime = 'TRADE_DISABLED'
        
        # --- Robust_OU_Estimator ---
        self.gap_buffer = deque(maxlen=params['ou_window_size'])
        self.current_half_life = -1
        self.current_hl_std_error = -1

    def _update_kalman(self, price):
        """Обновляет состояние Калмана, используя цену закрытия бара."""
        self.kf_state_mean, self.kf_state_cov = self.kf.filter_update(
            self.kf_state_mean, self.kf_state_cov, price
        )
        fair_value = self.kf_state_mean[0]
        fair_value_std = np.sqrt(self.kf_state_cov[0,0])
        return fair_value, fair_value_std

    def _update_hmm(self, bar_close_price):
        """Обновляет HMM на основе цены закрытия бара."""
        if len(self.hmm_observations) > 0:
            price_change = bar_close_price - self.hmm_observations[-1]
        else:
            price_change = 0
            
        self.hmm_observations.append(price_change)
        
        if len(self.hmm_observations) == self.hmm_observations.maxlen:
            try:
                obs = np.array(self.hmm_observations).reshape(-1, 1)
                regime_probs = self.hmm_model.predict_proba(obs)[-1]
                
                p_trend = regime_probs[0]
                p_sideways = regime_probs[1]
                p_dead = regime_probs[2]
                
                if p_trend > self.params['prob_threshold_trend']:
                    self.current_regime = 'TRADE_DISABLED'
                elif p_sideways > self.params['prob_threshold_sideways']:
                    if p_dead > self.params['prob_threshold_dead'] and self.current_half_life < self.params['sigma_dead_threshold']:
                        self.current_regime = 'DEAD_MARKET'
                    else:
                        self.current_regime = 'TRADE_ENABLED'
                else:
                    self.current_regime = 'TRADE_DISABLED'
                    
            except Exception as e:
                print(f"HMM update error: {e}")
                self.current_regime = 'TRADE_DISABLED'

    def _update_ou(self, gap):
        """Обновляет оценку Half-Life. Логика та же."""
        self.gap_buffer.append(gap)
        if len(self.gap_buffer) == self.gap_buffer.maxlen:
            try:
                gaps = np.array(self.gap_buffer)
                x = gaps[:-1]
                y = np.diff(gaps)
                slope, intercept, r_value, p_value, std_err = stats.linregress(x, y)
                
                if slope > 0 and slope < 1:
                    theta = -np.log(slope)
                    half_life = np.log(2) / theta
                    hl_std_error = std_err * (1 / (slope * abs(np.log(slope))))
                    self.current_half_life = half_life
                    self.current_hl_std_error = hl_std_error
                else:
                    self.current_half_life = -1
                    self.current_hl_std_error = 999
            except Exception as e:
                print(f"OU update error: {e}")
                self.current_half_life = -1
                self.current_hl_std_error = 999

    def _check_entry_signal(self, z_kalman):
        """Проверка условий входа. Логика та же."""
        if self.current_regime != 'TRADE_ENABLED':
            return None
        if abs(z_kalman) < self.params['s_entry']:
            return None
        if not (self.params['hl_min'] < self.current_half_life < self.params['hl_max']):
            return None
        if self.current_hl_std_error == 0 or (self.current_hl_std_error / self.current_half_life) > self.params['relative_uncertainty_threshold']:
            return None

        if z_kalman < -self.params['s_entry']:
            return 'LONG'
        if z_kalman > self.params['s_entry']:
            return 'SHORT'
        return None

    def _check_exit_signal(self, z_kalman, current_timestamp):
        """Проверка условий выхода. Логика та же, но с реальным временем."""
        # Take Profit
        if (self.position == 'LONG' and z_kalman > 0) or \
           (self.position == 'SHORT' and z_kalman < 0):
            return 'TAKE_PROFIT'
        # Stop Loss 1
        if (self.position == 'LONG' and z_kalman < -self.params['z_stop']) or \
           (self.position == 'SHORT' and z_kalman > self.params['z_stop']):
            return 'STOP_LOSS_HYPOTHESIS_FAILED'
        # Stop Loss 2 (с реальным временем)
        if (current_timestamp - self.entry_timestamp) > self.params['timeout_multiplier'] * self.current_half_life:
            return 'STOP_LOSS_TIMEOUT'
        # Stop Loss 3
        if self.current_regime != 'TRADE_ENABLED':
            return 'STOP_LOSS_REGIME_CHANGE'
        # Stop Loss 4
        if self.current_hl_std_error / self.current_half_life > self.params['uncertainty_threshold']:
            return 'STOP_LOSS_UNCERTAINTY_SPIKE'
        return None

    def process_bar(self, bar_data):
        """
        Основной метод для обработки 10-секундного бара.
        
        :param bar_data: Словарь с OHLCV данными, например:
                         {'timestamp': 1234567890, 'open': 100.5, 'high': 100.7, 'low': 100.4, 'close': 100.6, 'volume': 150}
        :return: Словарь с сигналом или None.
        """
        bar_close_price = bar_data['close']
        current_timestamp = bar_data['timestamp']

        # --- Обновление всех компонентов ---
        fair_value, fair_value_std = self._update_kalman(bar_close_price)
        gap = bar_close_price - fair_value
        z_kalman = gap / fair_value_std if fair_value_std > 0 else 0

        self._update_hmm(bar_close_price)
        self._update_ou(gap)

        # --- Проверка сигналов ---
        signal = None
        
        if self.position == 'HOLD':
            action = self._check_entry_signal(z_kalman)
            if action:
                # Вход будет по рынку на следующей свече, так как мы не знаем будущую цену
                signal = {
                    'action': action,
                    'price': None, # Цена будет определена на открытии следующего бара
                    'reason': f"Entry signal. Z={z_kalman:.2f}, HL={self.current_half_life:.1f}s, Regime={self.current_regime}"
                }
                self.position = action
                self.entry_price = bar_close_price # Сохраняем цену закрытия как референс
                self.entry_timestamp = current_timestamp

        elif self.position in ['LONG', 'SHORT']:
            reason = self._check_exit_signal(z_kalman, current_timestamp)
            if reason:
                signal = {
                    'action': 'CLOSE',
                    'price': None, # Выход по рынку на следующей свече
                    'reason': reason
                }
                self.position = 'HOLD'
                self.entry_price = 0
                self.entry_timestamp = 0
        
        return signal

# --- Пример использования ---
if __name__ == '__main__':
    # Параметры нужно будет заново подобрать под 10-секундные бары!
    # Особенно hl_min, hl_max и пороги неопределенности.
    STRATEGY_PARAMS_10s = {
        'initial_kf_mean': 100.0, 'initial_kf_cov': 1.0, 'measurement_noise_r': 0.5, 'process_noise_q': 0.05,
        'hmm_window_size': 50, 'hmm_update_interval': 1, # Обновляем каждый бар
        'prob_threshold_trend': 0.8, 'prob_threshold_sideways': 0.8, 'prob_threshold_dead': 0.9,
        'ou_window_size': 100, # Меньше окно для коротких баров
        'hl_min': 15, 'hl_max': 60, # Увеличиваем диапазон, т.к. данные приходят реже
        'relative_uncertainty_threshold': 0.4,
        's_entry': 2.0, 'z_stop': 3.0, 'timeout_multiplier': 2.0, 'limit_offset_ticks': 1, 'uncertainty_threshold': 0.5,
        'sigma_dead_threshold': 0.5
    }

    dummy_hmm = GaussianMixture(n_components=3, covariance_type='full', random_state=42)
    dummy_hmm.fit(np.random.rand(500, 1))

    signal_generator = HierarchicalMeanReversionSignalGenerator_10s(
        params=STRATEGY_PARAMS_10s,
        hmm_model=dummy_hmm
    )

    print("\n--- Starting 10s bar simulation ---")
    # Симуляция потока баров
    price = 100.0
    for i in range(200):
        price += np.random.normal(0, 0.1)
        if i == 50: price -= 0.8
        
        bar = {
            'timestamp': i * 10,
            'open': price,
            'high': price + np.random.uniform(0, 0.05),
            'low': price - np.random.uniform(0, 0.05),
            'close': price + np.random.uniform(-0.02, 0.02),
            'volume': np.random.randint(100, 500)
        }
        
        signal = signal_generator.process_bar(bar)
        if signal:
            print(f"Bar {i}: SIGNAL -> {signal}")
            
    print("--- Simulation finished ---")