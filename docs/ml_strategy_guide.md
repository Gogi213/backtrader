# Руководство: Создание торговой стратегии на основе LightGBM

## Введение: От жестких правил к обучаемой модели

Это руководство описывает переход от классической "сигнальной" стратегии, основанной на жестких правилах (`if/else`), к современной стратегии на основе машинного обучения (ML).

**Основная идея:** Вместо того чтобы вручную подбирать индикаторы и пороги, мы создадим модель, которая сама изучит исторические данные и научится находить паттерны, предвещающие рост или падение цены.

Мы будем использовать **LightGBM** — одну из самых мощных и быстрых реализаций градиентного бустинга.

---

## Этап 1: Подготовка данных (Feature Engineering & Labeling)

Это самый важный и трудоемкий этап. Качество "топлива" для нашей модели определяет 90% ее успеха. Наша задача — подготовить два ключевых компонента:
*   **Признаки (`X`)** — разнообразная информация о рынке для каждой свечи.
*   **Цель (`y`)** — "правильный ответ" для каждой свечи, который модель будет учиться предсказывать.

### 1.1. Установка библиотек

Нам понадобятся библиотеки для работы с данными, генерации признаков и самой модели.

```bash
pip install lightgbm pandas-ta scikit-learn joblib
```

### 1.2. Создание признаков (`X`)

Признаки (фичи) — это числовые представления рыночной информации. Чем больше качественных признаков мы дадим модели, тем лучше она сможет работать.

**Пример генерации с `pandas-ta`:**

```python
import pandas as pd
import pandas_ta as ta

# Загружаем ваш DataFrame с данными (df)
# ...

# Добавляем новые признаки в DataFrame
df.ta.rsi(length=14, append=True)
df.ta.macd(fast=12, slow=26, signal=9, append=True)
df.ta.bbands(length=20, std=2, append=True)

# pandas-ta автоматически добавляет столбцы, например:
# 'RSI_14', 'MACD_12_26_9', 'BBL_20_2.0', 'BBM_20_2.0', 'BBU_20_2.0'
```

**Категории признаков для генерации:**

*   **Ваши текущие индикаторы:** `NATR`, `prints_ratio`, `growth_pct`.
*   **Индикаторы моментума:** `RSI`, `Stochastic`, `CCI`, `MACD`.
*   **Индикаторы волатильности:** `ATR` (уже есть в NATR), `Bollinger Bands` (ширина канала `BBU - BBL`).
*   **Объемные индикаторы:** `On-Balance Volume (OBV)`.
*   **Статистические признаки:**
    *   Z-score для объема или `prints_ratio` за скользящий период (показывает аномальность текущего значения).
    *   Скользящие средние от других индикаторов (например, `SMA(RSI_14, period=5)`).
*   **Лаги:** Значения индикаторов за `N` свечей до текущей. Это дает модели память о недавнем прошлом.
    *   `df['RSI_14_lag_1'] = df['RSI_14'].shift(1)`
    *   `df['RSI_14_lag_3'] = df['RSI_14'].shift(3)`
*   **Скорость изменения (Momentum):** Насколько быстро меняется индикатор.
    *   `df['RSI_14_roc_1'] = df['RSI_14'].pct_change(1)`

**Цель — создать DataFrame с десятками, а то и сотнями столбцов-признаков.**

### 1.3. Разметка целевой переменной (`y`)

Это самый хитрый шаг. Нам нужно для каждой свечи определить, была бы сделка из нее успешной. Для этого используется **"метод тройного барьера"**.

**Концепция:**
Для каждой свечи `i` мы мысленно открываем сделку и ставим 3 "барьера":
1.  **Верхний барьер (Take Profit):** Цена, при достижении которой мы считаем сделку успешной.
2.  **Нижний барьер (Stop Loss):** Цена, при достижении которой мы считаем сделку провальной.
3.  **Вертикальный барьер (Timeout):** Максимальное время жизни сделки (например, 15 свечей).

**Логика разметки:**
*   Если цена **впервые** коснется верхнего барьера — ставим метку `1` (выигрыш).
*   Если цена **впервые** коснется нижнего барьера — ставим метку `-1` (проигрыш).
*   Если за время жизни сделки цена не коснулась ни одного из горизонтальных барьеров — ставим метку `0` (тайм-аут).

**Пример псевдокода для функции разметки:**

```python
def apply_triple_barrier(
    close_prices, 
    atr_values,
    tp_atr_multiplier, # Например, 2.0
    sl_atr_multiplier, # Например, 1.5
    lookahead_bars     # Например, 15
):
    labels = pd.Series(index=close_prices.index, data=0)

    for i in range(len(close_prices) - lookahead_bars):
        entry_price = close_prices[i]
        current_atr = atr_values[i]

        take_profit_level = entry_price + (current_atr * tp_atr_multiplier)
        stop_loss_level = entry_price - (current_atr * sl_atr_multiplier)

        for j in range(1, lookahead_bars + 1):
            future_high = close_prices.iloc[i + j] # Упрощенно, нужно смотреть high/low
            future_low = close_prices.iloc[i + j]

            if future_high >= take_profit_level:
                labels.iloc[i] = 1
                break # Выходим из внутреннего цикла

            if future_low <= stop_loss_level:
                labels.iloc[i] = -1
                break # Выходим из внутреннего цикла
    
    return labels
```
*В этом примере мы размечаем только лонг-сделки. Для шортов логика будет зеркальной.*

---

## Этап 2: Обучение и Валидация модели

### 2.1. Правильное разделение данных

**ЭТО КРИТИЧЕСКИ ВАЖНО!** Временные ряды нельзя перемешивать случайным образом, как обычные данные. Это приведет к "заглядыванию в будущее" и создаст иллюзию прибыльной стратегии.

Данные нужно делить строго хронологически:
1.  **Обучающая выборка (Train):** Самая старая часть данных (например, 70%). На ней модель учится.
2.  **Валидационная выборка (Validate):** Следующие 15% данных. На ней мы подбираем параметры модели (например, порог для входа).
3.  **Тестовая выборка (Test):** Самые свежие 15% данных. Эмулирует "будущее". На ней мы один раз, в самом конце, проверяем итоговое качество модели.

**Пример разделения:**

```python
# df - ваш DataFrame с фичами и метками
data_len = len(df)
train_end = int(data_len * 0.7)
val_end = int(data_len * 0.85)

X_train = df.iloc[:train_end]
y_train = df['target'].iloc[:train_end]

X_val = df.iloc[train_end:val_end]
y_val = df['target'].iloc[train_end:val_end]

X_test = df.iloc[val_end:]
y_test = df['target'].iloc[val_end:]
```

### 2.2. Обучение модели

С LightGBM это выглядит очень просто.

```python
import lightgbm as lgb

# Мы хотим предсказывать только выигрышные сделки
# Поэтому меняем метки -1 на 0, чтобы задача стала бинарной (1 - выигрыш, 0 - нет)
y_train_binary = y_train.copy()
y_train_binary[y_train_binary == -1] = 0

lgbm = lgb.LGBMClassifier(objective='binary', random_state=42)

lgbm.fit(X_train, y_train_binary)
```

### 2.3. Оценка качества

Простая `accuracy` (точность) здесь не подходит. Нам важнее метрика **Precision** (точность предсказания класса 1).

*   **Precision**: "Когда модель сказала 'покупай' (предсказала `1`), в каком проценте случаев она оказалась права?". Высокая Precision — наша главная цель.

**Самая главная проверка — финансовый бэктест.** Нужно написать простой симулятор, который будет "торговать" по сигналам модели на валидационной выборке и строить кривую капитала. Если кривая растет — мы на верном пути.

---

## Этап 3: Интеграция и Финальный Бэктест

### 3.1. Сохранение модели

Обученную модель нужно сохранить, чтобы не переобучать ее каждый раз.

```python
import joblib

# Сохраняем модель
joblib.dump(lgbm, 'lgbm_model.pkl')

# Загружаем модель
# loaded_model = joblib.load('lgbm_model.pkl')
```

### 3.2. Интеграция в симулятор

Теперь нужно изменить логику вашего `trading_simulator.py`. Вместо проверки `if i in signal_indices:`, цикл будет делать следующее:

```python
# Псевдокод
# model = joblib.load('lgbm_model.pkl')

for i in range(len(df)):
    # 1. Считаем все фичи для текущей свечи `i`
    current_features = create_features_for_bar(df, i) 

    # 2. Получаем вероятность выигрыша для лонга
    # model.predict_proba возвращает вероятности для [класса 0, класса 1]
    long_win_probability = model.predict_proba(current_features)[0][1]

    # 3. Принимаем решение
    if long_win_probability > 0.65: # 0.65 - это настраиваемый порог
        # Открываем длинную позицию
        # ...
```

### 3.3. Оптимизация порога

Порог вероятности (`0.65` в примере) — это ваш новый главный параметр. Его нужно подобрать на валидационной выборке.
*   **Высокий порог (напр. 0.8):** Сделок будет мало, но они будут очень точными (высокий Precision).
*   **Низкий порог (напр. 0.55):** Сделок будет много, но и ложных сигналов тоже.

Нужно найти баланс, который дает наилучшую кривую капитала на валидационном сете.

---

## Заключение

Этот путь превращает трейдинг из искусства в науку. Процесс итеративный: вы генерируете новые идеи для фичей, обучаете модель, проверяете результат, и так по кругу, постоянно улучшая ее предсказательную силу.
